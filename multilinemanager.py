'''Modul to setup and manipulate Sherpa model expressions which consist
of one background model and many identicla lines.
'''
import numpy as np
'''It is necessary to use from import * to get access to model types
which are specified as string (e.g. 'gauss1d') by the user.
'''
from sherpa.astro.ui import *

import shmodelshelper as smh

def modelstring(n_lines, contmodel, linemodel, contmodname = '', linemodname = '', prefix = ''):
    '''construct a string that describes a Sherpa model
    
    Parameters
    ----------
    n_lines : integer
        number of lines
    contmodel : string
        type of continuum model for Sherpa, e.g. `const1d`.
        Can contain a name and be a combination of models, e.g.
        `const1d.c1 + sin.s1`
    linemodel : string
        type of line model for Sherpa, e.g. `gauss1d`
    contmodname : string, optional
        name for continuum model. Will be autogenerated is missing.
    linemodname : string, optional
        basename for line models. Will be autgenerated if missing.
    prefix : string, optional
        prefix for all models. Use to provide package information:
    
            import sherpa.ui as ui
            modelstring( ..., prefix = 'ui')
            
        Prefix is *not* applied to fully specified continuum model, i.e.
        those which already contain `.`.
    
    Returns
    -------
    model : string
        string expression for Sherpa's `set_model` command
    '''
    prefix = prefix.strip()
    if prefix != '' and prefix[-1] != '.':
        prefix = prefix + '.'
    if '.' in contmodel:
        #contmodel contains the name as in const1d.c1
        model = contmodel.strip()
    else:
        if not contmodname:
            contmodname = contmodel.strip()[0]
        model = prefix + contmodel.strip()+'.'+contmodname.strip()
    
    if not linemodname:
        linemodname = linemodel.strip()[0]
    if linemodname == contmodname:
        linemodname = 'line' + linemodname
    for i in range(n_lines):
        model +=' + ' + prefix + linemodel.strip()+ '.' + linemodname.strip() +str(i+1)

    return model



class model(object):
    '''
    TBD:when looking up parts of the model use get_model_parts instead of n_lines+str(i). This makes it more flexible (modelcomponents might have been deleted by the user / other functions) and might get rid of self.n_lines alltogether.
    '''
    
    def __init__(self, contmodel, linemodel, contmodname = '', linemodname = '', convol_model = None, baseline = None):
        self.contmodel = contmodel
        self.linemodel = linemodel
        if not contmodname:
            self.contmodname = contmodel.strip()[0]
        if not linemodname:
            self.linemodname = linemodel.strip()[0]
        if linemodname == contmodname:
            self.linemodname = 'line' + self.linemodname
        self.baseline = baseline
        self.n_lines = 0
        self.convol_model = convol_model
        self.set_model()
        
    def set_model(self):
        if self.convol_model:
            set_full_model(self.convol_model + ' (' + self.modelstring() + ')')
        else:
            set_model(self.modelstring())
    
    def modelstring(self):
        return modelstring(self.n_lines, self.contmodel, self.linemodel, self.contmodname, self.linemodname)
    
    def add_line(self, **kwargs):
        self.n_lines += 1
        self.set_model()
        modelcomp = get_model_component(self.linemodname + str(self.n_lines))
        if self.baseline:
            smh.copy_pars(self.baseline, modelcomp)
        for key in kwargs:
            setattr(modelcomp, key, kwargs[key])
    
    def line_value_list(self, param, key = 'val'):
        '''get a list of values of one parameter for every line
        
        Parameters
        ----------
        param : string
            name of parameter e.g. `fwhm'
        key : string, optional
            As default the value of the parameters is returned, but Sherpa
            parameters have other properties e.g. `min` or `hardmin`.
            
        Returns
        -------
        parts_list : ndarray
        '''
        parts_list = smh.get_model_parts()
        return np.array([getattr(getattr(get_model_component(part), param), key) for part in parts_list if part.startswith(self.linemodname)])
    
    def line_list(self):
        '''
        Returns
        -------
        line_list : record array
            the record array holds the values of all parameters of the lines
            in the model.
            If the model has not lines, an empty array is returned.
        
        TBD: change to use line_value_list
        '''
        if self.n_lines == 0:
            return np.array([])
        else:
            line_list = np.zeros(self.n_lines, dtype = {'names': [p.names for p in get_model_component(self.linemodname+'1')], 'formats': self.n_lines * ['f4']})
            
            for i in range(self.n_lines):
                comp = get_model_components(self.linemodname + str(i+1))
                for par in comp.pars:
                    line_list[par.name][i] = par.val
                    
            return line_list
                
    def guess(self, wave, flux, peak, **kwargs):
        '''Guess simple line parameters
        
        This method guesses line paramters
        from the line position and the wave and flux vector.
        New parameters are added to the `kwargs` dictionary.
        
        Parameters
        ----------
        wave, flux : ndarray
            wavelength and flux vectors
        peak : integer
            index of peak position in `wave`,`flux` arrays
        
        Returns
        -------
        kwargs : dictionary
        '''
        if 'pos' not in kwargs:
            kwargs['pos'] = wave[peak]
        if 'ampl' not in kwargs:
            kwargs['ampl'] = flux[peak]
        if 'fwhm' not in kwargs:
            ampl = flux[peak]
            ind = np.where(flux > ampl/2.)[0]
            # if all flux was > ampl/2 ind would look like this:
            ind_ind = (ind == peak).nonzero()[0][0]
            ind_comp = np.arange(peak - ind_ind, peak + len(ind) - ind_ind, dtype = np.int)
            # find the outermost overlap points of ind and ind_comp
            bool_ind = (ind == ind_comp)
            kwargs['fwhm'] = wave[max(ind[bool_ind])] - wave[min(ind[bool_ind])]
        return kwargs


class GaussLines(model):
    def __init__(self, contmodel, contmodname = '', **kwargs):
        model.__init__(self, contmodel, 'gauss1d', contmodname = '', **kwargs)
        
class LorentzLines(model):
    def __init__(self, contmodel, contmodname = '', **kwargs):
        model.__init__(self, contmodel, 'lorentz1d', contmodname = '', **kwargs)

    def guess(self, wave, flux, pos, **kwargs):
        '''Guess ampl from flux and fwhm value.
        
        Due to an inconsistency in Sherpa the `lorentz1d.ampl` really means
        *area under curve* not *amplitude*. This methods convert the 
        amplitude to the area under the curve before initializing the line
        if the FWHM is also given.
        '''
        kwargs = super(LorentzLines, self).guess(wave, flux, pos, **kwargs)
        kwargs['ampl'] = np.pi * kwargs['fwhm'] / 2. * kwargs['ampl']
        return kwargs
      
class COSLines(LorentzLines):
    '''An example how to extend multilinemanagers
    
    This inherits from a multilinemanager and extends some methods to 
    include instrument specifics like the width of the LSF.
    '''
    def guess(self, wave, flux, pos, **kwargs):
        kwargs = super(COSLines, self).guess(wave, flux, pos, **kwargs)
        kwargs['fwhm'] -= 0.06
        return kwargs