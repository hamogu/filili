'''Modul to setup and manipulate Sherpa model expressions which consist
of one background model and many identicla lines.
'''
import numpy as np
try:
    import matplotlib.pyplot as plt
    has_mpl = True
except ImportError:
    has_mpl = False

'''It is necessary to use from import * to get access to model types
which are specified as string (e.g. 'gauss1d') by the user.
'''
from sherpa.astro.ui import *

import shmodelshelper as smh

def modelstring(n_lines, contmodel, linemodel, contmodname = '', linemodname = '', prefix = ''):
    '''construct a string that describes a Sherpa model
    
    Parameters
    ----------
    n_lines : integer
        number of lines
    contmodel : string
        type of continuum model for Sherpa, e.g. `const1d`.
        Can contain a name and be a combination of models, e.g.
        `const1d.c1 + sin.s1`
    linemodel : string
        type of line model for Sherpa, e.g. `gauss1d`
    contmodname : string, optional
        name for continuum model. Will be autogenerated is missing.
    linemodname : string, optional
        basename for line models. Will be autgenerated if missing.
    prefix : string, optional
        prefix for all models. Use to provide package information:
    
            import sherpa.ui as ui
            modelstring( ..., prefix = 'ui')
            
        Prefix is *not* applied to fully specified continuum model, i.e.
        those which already contain `.`.
    
    Returns
    -------
    model : string
        string expression for Sherpa's `set_model` command
    '''
    prefix = prefix.strip()
    if prefix != '' and prefix[-1] != '.':
        prefix = prefix + '.'
    if '.' in contmodel:
        #contmodel contains the name as in const1d.c1
        model = contmodel.strip()
    else:
        if not contmodname:
            contmodname = contmodel.strip()[0]
        model = prefix + contmodel.strip()+'.'+contmodname.strip()
    
    if not linemodname:
        linemodname = linemodel.strip()[0]
    if linemodname == contmodname:
        linemodname = 'line' + linemodname
    for i in range(n_lines):
        model +=' + ' + prefix + linemodel.strip()+ '.' + linemodname.strip() +str(i+1)

    return model



class model(object):
    '''
    TBD:when looking up parts of the model use get_model_parts instead of n_lines+str(i). This makes it more flexible (modelcomponents might have been deleted by the user / other functions) and might get rid of self.n_lines alltogether.
    '''
    
    def __init__(self, contmodel, linemodel, contmodname = '', linemodname = '', convol_model = None, baseline = None):
        self.contmodel = contmodel
        self.linemodel = linemodel
        if not contmodname:
            self.contmodname = contmodel.strip()[0]
        if not linemodname:
            self.linemodname = linemodel.strip()[0]
        if linemodname == contmodname:
            self.linemodname = 'line' + self.linemodname
        self.baseline = baseline
        self.n_lines = 0
        self.convol_model = convol_model
        self.set_model()
        
    def set_model(self):
        if self.convol_model:
            set_full_model(self.convol_model + ' (' + self.modelstring() + ')')
        else:
            set_model(self.modelstring())
    
    def modelstring(self):
        return modelstring(self.n_lines, self.contmodel, self.linemodel, self.contmodname, self.linemodname)
    
    def add_line(self, **kwargs):
        self.n_lines += 1
        self.set_model()
        modelcomp = get_model_component(self.linemodname + str(self.n_lines))
        if self.baseline:
            smh.copy_pars(self.baseline, modelcomp)
        for key in kwargs:
            setattr(modelcomp, key, kwargs[key])
    
    def line_value_list(self, param, key = 'val'):
        '''get a list of values of one parameter for every line
        
        Parameters
        ----------
        param : string
            name of parameter e.g. `fwhm'
        key : string, optional
            As default the value of the parameters is returned, but Sherpa
            parameters have other properties e.g. `min` or `hardmin`.
            
        Returns
        -------
        parts_list : ndarray
        '''
        parts_list = smh.get_model_parts()
        return np.array([getattr(getattr(get_model_component(part), param), key) for part in parts_list if part.startswith(self.linemodname)])
    
    def line_list(self):
        '''
        Returns
        -------
        line_list : record array
            the record array holds the values of all parameters of the lines
            in the model.
            If the model has not lines, an empty array is returned.
        '''
        if self.n_lines == 0:
            return np.array([])
        else:
            names = [p.name for p in get_model_component(self.linemodname+'1').pars]
            line_list = np.zeros(self.n_lines, dtype = {'names': names, 'formats': len(names) * ['f4']})
            for name in names:
                line_list[name] = self.line_value_list(name)
 
            return line_list
                
    def guess(self, wave, flux, peak, **kwargs):
        '''Guess simple line parameters
        
        This method guesses line paramters
        from the line position and the wave and flux vector.
        New parameters are added to the `kwargs` dictionary.
        
        Parameters
        ----------
        wave, flux : ndarray
            wavelength and flux vectors
        peak : integer
            index of peak position in `wave`,`flux` arrays
        
        Returns
        -------
        kwargs : dictionary
        '''
        if 'pos' not in kwargs:
            kwargs['pos'] = wave[peak]
        if 'ampl' not in kwargs:
            kwargs['ampl'] = flux[peak]
        if 'fwhm' not in kwargs:
            ampl = flux[peak]
            ind = np.where(flux > ampl/2.)[0]
            # if all flux was > ampl/2 ind would look like this:
            ind_ind = (ind == peak).nonzero()[0][0]
            ind_comp = np.arange(peak - ind_ind, peak + len(ind) - ind_ind, dtype = np.int)
            # find the outermost overlap points of ind and ind_comp
            bool_ind = (ind == ind_comp)
            kwargs['fwhm'] = wave[max(ind[bool_ind])] - wave[min(ind[bool_ind])]
        return kwargs
        
    def plot_model_components(self, id = None, legend = True):
        '''Plot contribution of individual model components
        
        If matplotlib can be imported, it is used directly, otherwise
        if falls back to Sherpa plotting (e.g. with chips).
        
        Parameters
        ----------
        id : None or Sherpa dataset id
        
        Returns
        -------
        fig : matplotlib figure instance
        '''
        if id is None:
            id = get_default_id()
        fig = plt.figure()
        if has_mpl:
            ax = fig.add_subplot(111)
            pl = get_data_plot(id)
            ax.errorbar(pl.x, pl.y, yerr=pl.yerr, fmt='+', label = 'data')
            for part in smh.get_model_parts():
                pl = get_model_component_plot(id, model = part)
                ax.plot(pl.x, pl.y, label = part)
            if legend:
                ax.legend(ncol = 2)
            ax.set_title('Individual model components')
        else:
            plot_fit()
            for part in smh.get_model_parts():
                plot_model_component(id, part, overplot = True)
        return fig

class GaussLines(model):
    def __init__(self, contmodel, contmodname = '', **kwargs):
        model.__init__(self, contmodel, 'gauss1d', contmodname = '', **kwargs)
        
class LorentzLines(model):
    def __init__(self, contmodel, contmodname = '', **kwargs):
        model.__init__(self, contmodel, 'lorentz1d', contmodname = '', **kwargs)

    def guess(self, wave, flux, pos, **kwargs):
        '''Guess ampl from flux and fwhm value.
        
        Due to an inconsistency in Sherpa the `lorentz1d.ampl` really means
        *area under curve* not *amplitude*. This methods convert the 
        amplitude to the area under the curve before initializing the line
        if the FWHM is also given.
        '''
        kwargs = super(LorentzLines, self).guess(wave, flux, pos, **kwargs)
        kwargs['ampl'] = np.pi * kwargs['fwhm'] / 2. * kwargs['ampl']
        return kwargs
      
class COSLines(LorentzLines):
    '''An example how to extend multilinemanagers
    
    This inherits from a multilinemanager and extends some methods to 
    include instrument specifics like the width of the LSF.
    '''
    def guess(self, wave, flux, pos, **kwargs):
        kwargs = super(COSLines, self).guess(wave, flux, pos, **kwargs)
        kwargs['fwhm'] -= 0.06
        return kwargs