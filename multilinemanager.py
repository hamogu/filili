'''Modul to setup and manipulate Sherpa model expressions which consist
of one background model and many identicla lines.
'''
import numpy as np
try:
    import matplotlib.pyplot as plt
    has_mpl = True
except ImportError:
    has_mpl = False

'''It is necessary to use from import * to get access to model types
which are specified as string (e.g. 'gauss1d') by the user.
'''
from sherpa.astro.ui import *

import shmodelshelper as smh

def modelstring(n_lines, contmodel, linemodel, contmodname = '', linemodname = '', prefix = '', names = []):
    '''construct a string that describes a Sherpa model
    
    Parameters
    ----------
    n_lines : integer
        number of lines
    contmodel : string
        type of continuum model for Sherpa, e.g. `const1d`.
        Can contain a name and be a combination of models, e.g.
        `const1d.c1 + sin.s1`
    linemodel : string
        type of line model for Sherpa, e.g. `gauss1d`
    contmodname : string, optional
        name for continuum model. Will be autogenerated is missing.
    linemodname : string, optional
        basename for line models. Will be autgenerated if missing.
    prefix : string, optional
        prefix for all models. Use to provide package information:
    
            import sherpa.ui as ui
            modelstring( ..., prefix = 'ui')
            
        Prefix is *not* applied to fully specified continuum model, i.e.
        those which already contain `.`.
    names : list of strings, optional
        If given, this will be used as lines names, if more lines than
        `len(names)` are required, the remaining names will be autogenerated.
    
    Returns
    -------
    model : string
        string expression for Sherpa's `set_model` command
    '''
    prefix = prefix.strip()
    if prefix != '' and prefix[-1] != '.':
        prefix = prefix + '.'
    if '.' in contmodel:
        #contmodel contains the name as in const1d.c1
        model = contmodel.strip()
    else:
        if not contmodname:
            contmodname = contmodel.strip()[0]
        model = prefix + contmodel.strip()+'.'+contmodname.strip()
    
    if not linemodname:
        linemodname = linemodel.strip()[0]
    if linemodname == contmodname:
        linemodname = 'line' + linemodname
    for i in range(n_lines):
        if i >= len(names):
            # autogenerate line name
            model +=' + ' + prefix + linemodel.strip()+ '.' + linemodname.strip() + str(i+1)
        else:
            # use linename from name list
            lname = names[i]
            if not lname.startswith(linemodname.strip()):
                lname = linemodname.strip() + lname
            model +=' + ' + prefix + linemodel.strip()+ '.' + lname

    return model



class model(object):
    '''
    TBD:when looking up parts of the model use get_model_parts instead of n_lines+str(i). This makes it more flexible (modelcomponents might have been deleted by the user / other functions) and might get rid of self.n_lines alltogether.
    '''
    
    def __init__(self, contmodel, linemodel, id = None, contmodname = '', linemodname = '', convol_model = None, baseline = None):
        self.contmodel = contmodel
        self.linemodel = linemodel
        self.id = id
        if not contmodname:
            self.contmodname = contmodel.strip()[0]
        if not linemodname:
            self.linemodname = linemodel.strip()[0]
        self.linemodname = self.linemodname.strip()
        if linemodname == contmodname:
            self.linemodname = 'line' + self.linemodname
        self.baseline = baseline
        self.convol_model = convol_model
        # remove old models first
        delete_model(self.id)
        self.set_model()
        
    def set_model(self, **kwargs):
        if self.convol_model:
            set_full_model(self.id, self.convol_model + ' (' + self.modelstring(**kwargs) + ')')
        else:
            set_model(self.id, self.modelstring(**kwargs))
    
    def modelstring(self, **kwargs):
        # if names is longer then line_name_list, then make model
        # with n_lines = len(names)
        if 'names' in kwargs:
            nlines = max(len(self.line_name_list()), len(kwargs['names']))
        else:
            nlines = len(self.line_name_list())
        return modelstring(nlines , self.contmodel, self.linemodel, self.contmodname, self.linemodname, **kwargs)
    
    def add_line(self, linename = None, **kwargs):
        '''add line to the model
        
        Parameters
        ----------
        linename : string, optional
            name for model component. Will be autgenerated is not given.
        '''
        linenames = self.line_name_list()
        # Check or autogenerate line names
        if linename is not None:
            if not linename.startswith(self.linemodname):
                linename = self.linemodname + linename
            if linename in linenames:
                raise ValueError('linename is already present')
            linenames.append(linename)
        else:
            i = len(linenames)
            while True:
                if (self.linemodname + str(i)) in linenames:
                    i += 1
                else:
                    linenames.append(self.linemodname + str(i))
                    break
        self.set_model(names = linenames)
        modelcomp = get_model_component(linenames[-1])
        if self.baseline:
            smh.copy_pars(self.baseline, modelcomp)
        for key in kwargs:
            setattr(modelcomp, key, kwargs[key])
    
    def line_name_list(self):
        '''get list of all model components that are lines
        '''
        parts_list = smh.get_model_parts(self.id)
        return list([part for part in parts_list if part.startswith(self.linemodname)])

    def line_value_list(self, param, linenamelist = None, key = 'val'):
        '''get a list of values of one parameter for every line
        
        Parameters
        ----------
        param : string
            name of parameter e.g. `fwhm'
        linenamelist : list, optional
            list of line names. Can be passed in to e.g. ensure e.g. a
            particular order of the lines or to retrieve only a subset of 
            values. 
        key : string, optional
            As default the value of the parameters is returned, but Sherpa
            parameters have other properties e.g. `min` or `hardmin`.
            
        Returns
        -------
        parts_list : ndarray
        '''
        if linenamelist is None:
            linenamelist = self.line_name_list()
        return np.array([getattr(getattr(get_model_component(part), param), key) for part in linenamelist])
    
    def line_list(self):
        '''
        Returns
        -------
        line_list : record array
            the record array holds the values of all parameters of the lines
            in the model.
            If the model has no lines, an empty array is returned.
        '''
        lines = self.line_name_list()
        if len(lines) == 0:
            return np.array([])
        else:
            names = [p.name for p in get_model_component(lines[0]).pars]
            line_list = np.zeros(len(lines), dtype = {'names': names, 'formats': len(names) * ['f4']})
            for name in names:
                line_list[name] = self.line_value_list(name, linenamelist = lines)
 
            return line_list
                
    def guess(self, wave, flux, peak, **kwargs):
        '''Guess simple line parameters
        
        This method guesses line paramters
        from the line position and the wave and flux vector.
        New parameters are added to the `kwargs` dictionary.
        
        Parameters
        ----------
        wave, flux : ndarray
            wavelength and flux vectors
        peak : integer
            index of peak position in `wave`,`flux` arrays
        
        Returns
        -------
        kwargs : dictionary
        '''
        if 'pos' not in kwargs:
            kwargs['pos'] = wave[peak]
        if 'ampl' not in kwargs:
            kwargs['ampl'] = flux[peak]
        if 'fwhm' not in kwargs:
            ampl = flux[peak]
            ind = np.where(flux > ampl/2.)[0]
            # if all flux was > ampl/2 ind would look like this:
            ind_ind = (ind == peak).nonzero()[0][0]
            ind_comp = np.arange(peak - ind_ind, peak + len(ind) - ind_ind, dtype = np.int)
            # find the outermost overlap points of ind and ind_comp
            bool_ind = (ind == ind_comp)
            kwargs['fwhm'] = wave[max(ind[bool_ind])] - wave[min(ind[bool_ind])]
        return kwargs
        
    def plot_model_components(self, legend = True):
        '''Plot contribution of individual model components
        
        If matplotlib can be imported, it is used directly, otherwise
        if falls back to Sherpa plotting (e.g. with chips).
        
        Returns
        -------
        fig : matplotlib figure instance
        '''
        fig = plt.figure()
        if has_mpl:
            ax = fig.add_subplot(111)
            pl = get_data_plot(self.id)
            ax.errorbar(pl.x, pl.y, yerr=pl.yerr, fmt='+', label = 'data')
            for part in smh.get_model_parts():
                pl = get_model_component_plot(self.id, model = part)
                ax.plot(pl.x, pl.y, label = part)
            if legend:
                ax.legend(ncol = 2)
            ax.set_title('Individual model components')
        else:
            plot_fit(self.id)
            for part in smh.get_model_parts():
                plot_model_component(self.id, part, overplot = True)
        return fig

class GaussLines(model):
    def __init__(self, contmodel, id = None, contmodname = '', **kwargs):
        model.__init__(self, contmodel, 'gauss1d', id, contmodname = '', **kwargs)

class LorentzLines(model):
    def __init__(self, contmodel, id = None, contmodname = '', **kwargs):
        model.__init__(self, contmodel, 'lorentz1d', id, contmodname = '', **kwargs)

    def guess(self, wave, flux, pos, **kwargs):
        '''Guess ampl from flux and fwhm value.
        
        Due to an inconsistency in Sherpa the `lorentz1d.ampl` really means
        *area under curve* not *amplitude*. This method converts the 
        amplitude to the area under the curve before initializing the line
        if the FWHM is also given.
        '''
        kwargs = super(LorentzLines, self).guess(wave, flux, pos, **kwargs)
        kwargs['ampl'] = np.pi * kwargs['fwhm'] / 2. * kwargs['ampl']
        return kwargs
      
class COSLines(LorentzLines):
    '''An example how to extend multilinemanagers
    
    This inherits from a multilinemanager and extends some methods to 
    include instrument specifics like the width of the LSF.
    '''
    def guess(self, wave, flux, pos, **kwargs):
        kwargs = super(COSLines, self).guess(wave, flux, pos, **kwargs)
        kwargs['fwhm'] -= 0.06
        return kwargs